### 1、shader单元模型

见RT4。

### 2、从C++结构体到shader资源

1. 输入C++数据---->CPU buffer（实际上就是数组，只不过是在显存中）
2. 将GPU buffer绑定到shader的槽上
3. 在shader中定义对应的结构体
4. 告诉GPU如何解释shader中输入的数据，以使其对应到shader 中定义的结构体，这一步通过vertexLayout(DX11)或者VertexAttribPointer(OpenGL)来说明，而且一般只有vertex数据需要特别说明。其他的index, constant, texture都只要适当的说明就可以了。

### 3、OpenGL的资源格式

OpenGL的资源一般是给每个资源冠以某个id，以此将其与实体对象地址抽象出来。比如VAO，VBO，EBO这些，只需要指定对应的参数即可。更像是configureable的，而不是programable的。

### 4、公匙和私匙

公匙和私匙是一个相对的概念，而且公匙和私匙并不是用来进行双向传递的。一般是接收方，生产一对公匙和私匙，并将公匙发给发送方，这样发送方发送的数据即使被截获，公匙也泄露了也不能知道信件的内容。当然，如果这个时候，接受方发送数据给发送方，信件和公匙都被截获了自然能知道信件的内容。所以公匙和私匙只能用做单向的，这样就不会被破解。只有用私匙才能破解公匙加密的信件，也就是说用公匙破解不了。传统的对称加密，别人要是知道了钥匙就能破解，但是你又不能不给别人钥匙，要不然别人怎么给你发消息呢，所以钥匙的保存很困难。但是实际上，非对称加密本质上就和对称加密不同，所以最好不要尝试用对称加密的思路去理解。现在就是只要你不把私匙传出去就永远破解不了，但是别人却能够安全的给你发信息。

### 5、纹理绑定

先绑定两个纹理到对应的纹理单元，然后定义哪个uniform采样器对应哪个纹理单元

我们还要通过使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元。我们只需要设置一次即可，所以这个会放在渲染循环的前面：

其中，value是指texture units, GL_TEXTURE0, GL_TEXTURE1这些，但是不是GL_TEXTURE0的值，而是0，1，2（分别对应GL_TEXTURE0, GL_TEXTURE1）这些值，这里是真的离谱。而且也不是glGenTextures(1, &textureID)的这个textureID。

```c++
   glUniform1i(glGetUniformLocation(ourShader.ID, "texture1"), value);
```

也就是说绑定texture有这样一些步骤：

1. 将texture以字节流读入，然后绑定到GPU上，这时还只是资源，得到对应textureID

2. 在shader中创建texture的变量，形如 uniform sampler2D texture1. 

3. 将shader中的这个uniform变量使用glUniform1i绑定到shader的texture槽中，也就是对应的texture unit，取值参考其上。

4. 将textureID也就是这个GPU资源与对应的texture unit绑定。

也就是

```c++
 glActiveTexture(GL_TEXTURE0);
 glBindTexture(GL_TEXTURE_2D, texture1);
```

另外，对于shader中的任意的sampler2D变量，如果你没有显示的调用glUniform1i为该变量绑定槽的话，那么OpenGL默认是绑定第一个槽，就是GL_TEXTURE0。无论你有几个sampler2D，它都会绑定到这个上面去。（PS：假如要追求极致的速度，那么可以把几张纹理合并成一张纹理，然后对uv做偏移进行采样，就可以达到采样多张纹理的效果）

### 6、OpenGL状态机

OpenGL状态机讲实话是一个很迷惑的东西，初学者恐怕难以理解OpenGL的各种bind操作。经过几个小时的debug和各种测试，OpenGL的状态机有以下几个特点。

1. OpenGL的bind操作对于不同的GPU对象，一般来说是不会互相影响的。比如说glUseProgram和glBIndTexture就是不会互相影响的。glUseProgram之后对于Shader所做的任何工作，对于Texture都是独立的。也就是说你可以为Uniform sampler2D绑定一个不存在的槽位。
2. OpenGL对于GPU对象的任何操作，都要在bind之后进行。假如你要改变纹理的WrapMode，那么你就要先glBindTexture才行。假如你之前绑定了别的纹理，那么现在这个setWrapMode就是对于别的那个纹理进行的。因为不知道别人（别的程序）有没有在你的这个函数调用前bind过，所以最好所有操作前先bind一次。这或许也是为什么每次执行渲染都需要bind一次吧。



### 7、纹理格式RGB、RGBA引发的错误

如题，类似有程序突然崩溃，debug显示栈空（栈空就是数据没有对应上，原数据太少），出现重影（原数据太多）。

### 8、摄像机的相关问题

首先要理解欧拉角的公式要从理解单位圆开始。在Y和X,Z平面形成的pitch角度，其”单位圆“的半径其实是XZ平面的那条线段的长度，所以x的坐标就是1（xz平面的斜边长度）* cos（pitch） * cos（yaw）。

然后就是要注意欧拉角的初值是pitch=0, yaw=-90（看向-Z方向）（这和你摄像机的初始位置有关，你摄像机如果初始位置是在（1，1，1），欧拉角的初值就不一样了，不然就会跳）。还有一个bug就是注意角度和弧度的转换，sin函数都是用的弧度。pitch<-90或者pitch>90的时候会反转，应该是单调性的问题，不过这个整个一函数太复杂了我没推过。

#### 万向节死锁问题

https://blog.csdn.net/AndrewFan/article/details/60981437?spm=1001.2014.3001.5501

主要是因为Z, X, Y旋转，xy是固定轴向，z是相对的，所以当x=-90时，y和z就在同一轴向，这样就损失了自由度。在这种情况下（同一个轴有两个方向可以旋转）就会造成过程不唯一（给定某个角度集合，过程不唯一）。

另外鼠标的回调函数传进来的值一般都是10，-10这样，应该是一个介于屏幕分辨率与其相反数之间的整数。

四元数不是特别清楚，不过计算旋转的公式并不复杂，q=(sin(theta/2)N, cos(theta/2)), p'=q * p * q-1

其中q是四元数（vec3, scale）的形式，N向量是对应轴，theta是角度，p,p'是绕轴旋转前后的点。

### 9、颜色

颜色是个很直观但是很深刻的概念。为什么我们在写shader的时候都是用“反射率”来描述一个物体的固有色呢，因为物体是通过反射而显出人眼里的颜色，而反射率，代表的是对应颜色在该物体是反射的程度，(1,0,0)的光打在(0,1,0)的物体上得到的就是(0,0,0)是黑色，这也是为什么“物体反射光“这一过程用“乘法”来表示，就是各个rgb分量的颜色都对应相乘，就是对应光的分量进行了反射，这就是物体的固有色叫做反射率的原因吧。然后不同的高光、散射光、漫反射光相加，是因为它们并不是”物体反射光“这一过程，而是”不同来源的光同时进入人眼“这一过程，所以用”加法“来表示。

### 10、找bug的一些经验

先看是顶点问题还是着色问题，如果着色没问题，那么就是顶点有问题。顶点无非就是顶点数据、数据的解释方式、绑定对应的槽位，vertexShader的变量、计算、mvp transform。

然后个人经验，多半是哪个操作在使用gl的函数前忘记绑定对应的资源了。对于这个问题，更好的方法是把shader对应的操作封装起来，暴露出来的接口就不需要考虑glUseProgram的问题了。

其实过程上出bug的概率比较小，大部分bug都是出在数据的输入与解释，数据的取值范围是多少，是不是与你的函数对应，数据如何解释，偏移是多少，stride是多少，然后就是参数，绑定的buffer对不对，有没有用的是别的宏。

### 11、 纹理

纹理的本质就是一个位置对应颜色的映射函数，能够让我们**逐片段**（因为每个片段都有独立的位置）索引其独立的颜色。

### 12、关于映射时是用String还是int

如果一个对象是我自己创建的，那么我在它创建的时候保存它的编号，更极端点，保存它的地址，我就可以调用它。但是假如一个对象，不是我创建的，那我需要使用它，我就需要描述它，那么我就会“叫”它的名字，什么时候我不需要“叫”它的名字呢，就是这个序号它本身就包含有我需要的对象的信息，就是1就代表了这个人，那么实际上，更本质一点来说，就是符号，这个1就是它的名字。还有一种情况就是遍历数组，然后找到有相应名字的对象，但是那既然如此为什么不直接用String去映射？也就是说，如果我不知道一个对象，我势必需要去描述它，然后才能得到它，这个时候就需要名字。而什么时候需要string，就是序号不足以描述它的时候。就好像，面前有0，1，2，3，4五个人，要你选一个当老婆，那这个时候，压根就没法选。

### 13、背面剔除

背面剔除实际上有两步，第一步是定义三角形的顶点顺序是逆时针（或者顺时针）（这一步是指你面对每一个三角形朝外的那一面，来定义它的顶点顺序，如果随意定义顶点顺序，那么123有可能是顺时针，有可能逆时针）

第二步是判断这个环绕顺序123摄像机看起来是逆时针还是逆时针。这其实要进行两步计算，首先计算叉积（判断点是否在三角形内是叉积的另一个用途），然后计算这个叉积和摄像机向后的向量的点乘，如果小于0说明是逆时针。

也就是说三角形的顺序是固定的，就是三角形的这个顺序的向量是固定的，只是看你怎么去看它。所谓内表面，外表面实际上都是一个面，并没有什么内表面和外表面的分别，只有这个面是front，还是back。

### 14、skybox

先提一下纹理的上下问题。纹理的原点有的是在左上有的是在左下，OpenGL的是在左下，载入纹理的时候要注意。

然后就是OpenGL深度写入默认是关闭的，如果总是打开，要检查是不是哪里动了。

skybox乍一看很简单，根据实现和深度测试的状态，实际上可能有很多种情况。

首先是view矩阵舍弃平移。这是最一般的skybox实现。view矩阵，本质上来说，就是把空间中所有物体随着摄像机一起移动，舍弃了平移，就意味着这个物体即使摄像机和其他物体都移动了，它还在原地，对于skybox来说，就是它始终是在原点那个位置。另外skybox在vertex shader里也是要乘projection的，（vertex shader输出的是齐次坐标）不然在光栅化时还会除以z，到时候就不对了。这可以引申出skybox的两个实现，第一个是将model的顶点就设为-1，1这些，然后在vertex shader里把w改成1（但是实际上还是不行，因为OpenGL不是单纯的除以w），第二个就是将z分量设为w算出来就一直是1了。

然后就是要GL_LEQUAL，不然就会像两个重叠的三角形那样，随着摄像机的移动不断的出现锯齿和闪烁。

另外，至今为止的所有bug都是参数设错了，调试一两小时，这次也是，GL_ARRAY_BUFFER设成了GL_VERTEX_ARRAY。前面一次是GL_RGBA设成了GL_RGB。debug一定一定要检查参数，不要到最后看参考比对时才发现，工作中可是没有参考答案的。

### 15、透视投影变换

1. 有的摄像机缩放矩阵是n-f这是在n>f的情况下算的，比如说左手系。
2. 透视变换它是非线性的，因为除了z。直观来说，就是空间被挤压了。另外它有两个好的特性，线还是线，面还是面。这推出以下推论：
   * 线框确实是被挤压的，本来平行变相交。对于顶点而言是正确的。但是对于其上进行插值的数据而言就是不正确的了。比如一个顶点的位置原本在中间，但是因为扭曲空间变到了前面，而正确的插值是往前稍微平移一点点，而不是直接被扭曲过去。扭曲就意味着有的点是重合的，自然是不正确的。要得到透视正确的插值就需要除以1/w。而将1/w进行插值，然后再对每个属性去除以这个1/w就行了，具体的算法可能有所差异大概就是这样。
   
   * 唯一不用变的是z，因为z/w有着很好的特性，近处精度高，远处精度小。而且只是用来排序，这个z/w是递增的函数。
   
   * 另外，纹理的坐标是不需要乘以mvp矩阵的。因为纹理意味着点和纹理的映射关系，而不是点和空间的映射关系。
   
     

任何变换如果把它作为一个空间（可以简单的看成一个体积，正方体啥的）去理解会直观很多，线性变换就是一个空间旋转缩放，齐次变换就是将这个空间移动，透视变换就是将一个平头截体压缩成了一个矩形体（但是线段是没有被扭曲的，也就是直线还是直线，是线段扭曲的是透视除法）。

### 16、阴影

shadow acne的原因在于对于和光线不垂直的表面，多个像素映射到阴影贴图的同一个像素中，直观上理解就是取的是这多个像素深度的平均值，所以会有相间的条纹。

有两种解决方法，一种是用bias，使得currentDepth更小，直观上理解就是取上述多个像素的最小值，但这个方法会带来peter panning（悬浮）。

另一种是在渲染深度贴图时开启正面剔除，使得深度贴图中的深度值更大，那么就更容易照亮，也可以解决acne，但是这只对封闭的物体有效，而对地面这样只有一个面的物体无效。它比bias好的地方在于不会带来peter panning的问题。

锯齿。锯齿主要是在阴影边缘产生，通过多次采样柔和阴影，实际上对于非边缘的阴影来说是相当浪费的。

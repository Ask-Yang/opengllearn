**1. 为什么构造函数不能为虚函数？**

  虚函数的调用需要虚函数表指针，而该指针存放在对象的内容空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。

 

**2. 为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？**

  首先析构函数可以为虚函数，而且当要使用基类指针或引用调用子类时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。

  举例说明：

  子类B继承自基类A；**A \*p = new B; delete p;**

  1） 此时，如果类A的析构函数不是虚函数，那么delete p；**将会仅仅调用A的析构函数，只释放了B对象中的A部分，而派生出的新的部分未释放掉。**（因为这个是对象A的指针，不是B的）

  2） 如果类A的析构函数是虚函数，delete p; 将会先调用B的析构函数，再调用A的析构函数，释放B对象的所有空间。

  补充： B *p = new B; delete p;时也是先调用B的析构函数，再调用A的析构函数。

### 2、 raw pointer, smart pointer , reference

smart pointer should be used in the case that you own this object,

the reference should be used in the case that you don't own this object, and you won't change the reference, and can not be null.

raw pointer for object you don't own but you want to change it in some cases. The better implementation for that case maybe use polymorphism（多态）.

总而言之，内存分配的时候用智能指针，如果是需要一个对象，那么用引用。能不用就不用吧。指针最大的问题就是它可以为空吧，所以我们要避免制造一个不知道是否存在的怪物，以降低程序出错的可能性，为此，如果真到必须使用指针的时候，也就是允许nullptr的时候，我们应该首先检查我们的类设计才对。给每个对象一个明确的生命期，可能是使用C++时最应该注意的事情。

java的reference可以更改？java是定义一个引用，然后必须要在构造函数里初始化，只不过可以放在构造函数体里，而不是使用初始化列表。

### 3、 基类、派生类

派生类一定是基类，但是基类不一定是特定派生类，所以只能基类指向派生类。

一个基类指针指向一个派生类对象，这个时候调用的是派生类的构造函数。但是对于编译器而言，这个指针仅仅只是一个基类指针而已，你只能通过这个指针访问基类的成员。唯一的例外就是虚函数。而虚函数的实现是通过虚函数表来实现的，也就是将基类的同名虚函数覆盖了，指向了派生类的虚函数，也就是说，对于编译器而言，这个指针还是一个基类指针，只不过发生了动态绑定，这个“基类的函数”变成了派生类的函数，而这个派生类的函数自然可以访问派生类的成员，又因为执行的是派生类的构造函数，所以所有派生类成员这个虚函数都可以访问，要注意，并不是基类指针可以访问派生类，而是基类的某个函数发生了动态绑定，使得这个函数指向了派生类，因此可以访问派生类。对于这个指针而言，派生类的一切都是不可见的。

另外，考虑以下情况：

```c++
class a {
public:
	a() {
		cout << "a" << endl;
		//func();
	}
	virtual void func() = 0;// 纯虚函数不能在父类中被调用，虽然理论上来说可以被子类动态绑定，但是你不知道会不会有子类去覆写它，所以编译就不会通过
	virtual void print() {
		cout << "aPrint" << endl;
	}
	void init() {
		cout << "a" << endl;
		print();
	}
};

class b : public a {
public:
	b()
		:a() {
		cout << "b" << endl;
		init();//因为成员函数调用的本质是this指针，所以在自己内部调用成员函数也会发生动态绑定
	}
	void func() {
		std::cout << "b" << std::endl;
	}
private: //访问限定符不影响虚函数的动态绑定
	void print() {
		cout << "bPrint" << endl;
	}
};
```

C++ 归根结底就是只要你声明了函数我就能去使用，但是只有这个函数真的有实现，链接才会成功。

然后就是虚函数，一般是搭配基类指针使用。基类指针所指向的对象实际上是派生类的对象，所以所有基类的函数，只要会被虚函数替换的，都会替换。

#### 基类、派生类的构造顺序

```c++
struct c {
	c(int in) {
		a = in;
		cout << "c" << endl;
	}
	int a = 11;
};
struct d : public c {
	d(int in) 
		:c(in) // 这里也是先构造基类，只不过用的是带参的构造函数。默认是不带参的
	{
		cout << b;
	}
	int b = a + 1;
};
c* p = new d(2);
```

答案是3。

先按基类声明顺序从左到右构造基类，再构造派生类。

先按成员变量声明顺序从上到下构造成员变量，再调用类自身构造函数。

